% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/app_server.R
\name{app_server}
\alias{app_server}
\title{Server side of the dv.manager}
\usage{
app_server(input = NULL, output = NULL, session = NULL, id = NULL)
}
\arguments{
\item{input, output, session}{Internal parameters for {shiny}.
DO NOT REMOVE.}

\item{id}{id when app_server is used as a module}
}
\description{
Server side of the dv.manager
}
\section{golem}{

This server side is built as a golem application. Therefore it will make use of the \link[golem:get_golem_options]{golem::get_golem_options}
functionality. Particularly, it will receive three variables through this channel: module_list, data and filter_data.
All this variables are specified in the \code{\link[=run_app]{run_app()}} call.
}

\section{data}{

\emph{data} is the fundamental data source for the application launched by the dv.manager
\itemize{
\item This data source is a named list of:
\itemize{
\item lists of data.frames as loaded by dv.loader
\item of functions that when called return a list of data.frames
}
\item Entries of the list will selected and then each of the data.frames will be dispatched to each module according to
the code that defines the application
\item The data dispatched to the modules will be filtered according to a global \emph{dv.filter} (see filter_data section)
\item The name of the selected dataset will appear in the sidebar, according to the name provided the list
\item The date of the dataset will be automatically displayed by selecting the earliest and the latest date of the
composing data.frames.
\itemize{
\item \emph{dv.manager} assumes that all data.frames within a dataset have an attribute \emph{meta}, and within it,
it will look for the entry \emph{mtime}
\item This assumption is met when the dataset is loaded directly with dv.loader, nonetheless, this attributes may
need to be created for new derived data.frames during preprocessing
It is the programmer obligation to check that all datasets have this attribute and that is correct.
}
}
}

\section{filter_data}{

The datasets in \emph{data} will be filtered in the following way:
\enumerate{
\item A dataset for global filtering is defined by \emph{filter_data}
\item This dataset is filtered by \emph{dv.filter} and the user input
\item The remaining USUBJIDs (by default, see \emph{filter_key} field in run_app) are used to filter the rest of the
datasets
}
}

\section{module_list}{

\emph{module_list} will contain a list of the modules to be used in the application. Each entry in the list will contain
the following fields:
\itemize{
\item The name of each entry of the list (unique), will be used in the selection menus, therefore must be meaningful and
intended for human use.
\item \strong{ui}: A UI function that will need a single parameter, id. Almost always it will be the other entry module_id
\item \strong{server}: A function that will receive a single parameter. See \code{vignette("arguments_from_module_manager")}
\item \strong{module_id}: A unique alphanumeric string that will identify the module, it will be used internally therefore it
is intended for machine use.
Additionally, it will expect a value \strong{input$mod_select} to identify which module is currently selected. Here it is
only used to produce a log with the selection
but it will be used for selecting in the UI conditional panels.
}
}

\keyword{internal}
